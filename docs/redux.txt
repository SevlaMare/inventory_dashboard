III - making a new feature
1 create the feature component, inject in a page.
  optional don't use redux yet. make it work then extract.

2 create SLICE: (new feature)
  new file, copy template
  rename actions/exports
  create reducers fxs
  import slicer on redux store.

3 from component, import the slice and apply the reducers. (replace handlers)
  to call the reducers, import dispatcher + slicer.
  dispatch need to be instanciated, it will link w redux store living on provider.
  to use the useDispatch pass the ACTION desired (eg get / set).
    if react state was: const [count, setCount] = useState(0);
    then count would be:
      useSelector
    and setCount becomes: with the action/reducer name as argument:
      useDispatch(<action>)
  note that all the logic to modify the state, must live in the reducer (centralized!)
  and the handlers are just forwarding the params, and the reducers take care of it.
-------------
I - setup
1 inject redux (aka state machine)
  ReduxProvider, comes built-in, so just wrap the app. (main.tsx)
  the provider receive the store (state object with default values)

2 define the STORE
  aggregate the REDUCERs
  inject middlewares (eg for async state changes handling)

3 create SLICES by features
  define the initial state
  define REDUCERs (functions that modify the state for this feature)
  export the actions (name operations to modify the state)
  export the reducer (to be injected in the store)
-------------
II - persist store
  use a listener to subscribe to changes (actions dipacth), works like autosave.
  preloadedState -> in the store, it will fallback to reducers on undefined.
    preloadedState: getStorageItem(reduxStoreKey),

-------------
concepts
  IMMUTABILITY: every change on state, generate a new object, not a modified one.
    since every new state is a whole new obj, it can be used to keep a history stack.
